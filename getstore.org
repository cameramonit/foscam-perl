* Overview
The foscam-perl project is free software. This web page documents Perl programs I've written to get the video from a Foscam camera. foscam-getstore-asf.pl and foscam-daemon.pl are fully functional alpha quality programs. You can copy and paste them from this page since. You can rsync the foscam-perl project with rsync -av foscam-perl.shilohsystem.com::foscam-pel. This project
* The foscam-perl.pl program
** Usage
#+BEGIN_EXAMPLE
foscam-getstore-snapshot.pl "camera_name" "ip_address"
#+END_EXAMPLE
where camera_name is an arbitrary name you give a Foscam camera and ip_addess naturally 
** What foscam-perl.pl does
** The main routine (foscam-perl.pl)
#+begin_src perl :tangle bin/foscam-perl.pl :shebang #!/usr/bin/env perl :noweb yes
  <<pragma-chunk>>
  my $GET = 0;
  my $GETSTORE = 1;
  my $ANNOTATE = 0;
  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
                          clock_gettime clock_getres clock_nanosleep clock
                          stat );
  
  # get seconds and microseconds since the epoch
  my ($s0, $s1, $usec0, $usec1, $t0, $t1) = 0;
  
  my $image = Image::Magick->new;
  <<read-config-chunk>>
  <<get-options-chunk>>
  my $index = '00';
  
  $interval = 0.60;
  
  my $start_time = time;
  my $url = "http://admin:\@$ip_address/snapshot.cgi";
  $url = "http://admin:\@$ip_address/snapshot.cgi";
  my $file = build_image_filename($camera_name, $BASE_DIR, 'jpg' );
  my $logfile = "$BASE_DIR/log.$camera_name";
  open(my $log, ">", $logfile) or die "Unable to open $logfile: $!";
  while ( time < ($start_time + $duration) ) {
      ($s0, $usec0) = gettimeofday();
      print $log "--> Start at ", $s0 + $usec0/1_000_000, "\n";
      my ( $file, $text ) = build_image_filename($camera_name, $BASE_DIR, 'jpg');
      ($s0, $usec0) = gettimeofday();
      if ( $GET ) {
          my $jpeg = get($url);
          ($s0, $usec0) = log_time( $log, $s0, $usec0, "retrieved jpeg" );
          my $j = $image->BlobToImage($jpeg);
          ($s0, $usec0) = log_time( $log, $s0, $usec0, "\$image->BlobToImage" );
          if ( $ANNOTATE ) {
              print "DEBUG: \$ANNOTATE = $ANNOTATE\n";
              $image->Annotate(x => 5, y => 20, font=>'kai.ttf', pointsize=>20, fill=>'gold', text=>$text);
              ($s0, $usec0) = log_time( $log, $s0, $usec0, "\$image->Annotate" );
          }
          $j = $image->Write($file);
      } elsif ($GETSTORE) {
          my $jpeg = getstore($url,$file);
          ($s0, $usec0) = log_time( $log, $s0, $usec0, "getstore retrieved jpeg" );
      }
      my $latest_link = "$BASE_DIR/latest-${camera_name}.jpg";
      unlink($latest_link);
      symlink($file, "$latest_link") or die "Unable to symlink";
      @$image = ();
      ($s1, $usec1) = gettimeofday();
      $interval = 1 - $usec1/1_000_000;
      Time::HiRes::sleep ($interval);
  }
  sub log_time {
      my ( $filehandle, $s0, $usec0, $text ) = @_;
      my ($s1, $usec1) = gettimeofday();
  #   my $fetch_time =  ( $s1 + $usec1/1_000_000 ) - ( $s0 + $usec0/1_000_000 );
      my $elapsed_time = ($s1 + $usec1 * 1e-6) - ($s0 + $usec0 * 1e-6);
      my $milliseconds = int($elapsed_time * 1000);
      print $filehandle "$text in $milliseconds ms\n";
      return gettimeofday();
  }
  <<build-jpeg-filename-subroutine>>
  
#+end_src  
* Library
** foscam-perllib.pm
#+BEGIN_SRC perl :tangle lib/foscam-perllib.pm :padline no :noweb yes
<<make-image-dir-subroutine>>
<<build-image-filename-subroutine>>
1;
#+END_SRC  
*** The make_image_directory subroutine
#+name: make-image-dir-subroutine
#+BEGIN_SRC perl
  sub make_image_dir {
      my ( $base_dir, $year, $mon, $mday, $camera_name, $hour ) = @_;
      my $directory = "$base_dir/$year/$mon/$mday/$camera_name/$hour";
      use File::Path qw(make_path);
      if ( ! -e $directory ) {
          make_path($directory, { verbose => 1 }) or die "Unable to mkdir --parent $directory";
      }
      return $directory;
  }
#+END_SRC    
*** The build_image_filename subroutine
#+name: build-image-filename-subroutine
#+begin_src perl
  sub build_image_filename {
      my ( $camera_name, $base_dir, $type ) = @_;
      my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
          localtime(time);
      $year -= 100;
      $mon += 1;
      $hour = sprintf("%02d", $hour);
      $min = sprintf("%02d", $min);
      $sec = sprintf("%02d", $sec);

      my @days = qw(Sun Mon Tue Wed Thu Fri Sat);
    
      my $directory = make_image_dir( $base_dir, $year, $mon, $mday, $camera_name, $hour );
    
      my $file = "$directory/${min}${sec}.$type";
      my $text = "$days[$wday] $hour:$min:$sec";
      return ($file, $text);
  }
#+end_src

** ffmpeg-foscamlib.pm
*** Meaning of ffmpeg options
    - -y :: Overwrite output files without asking.
#+BEGIN_SRC perl :tangle lib/ffmpeg-foscamlib.pm :padline no :noweb yes
  sub make_two_pass_webm {
      my ( $input, $output ) = @_;
      my $input = shift;     # %04d.jpg
      my $quality = 'good';
      my $video_codec = 'libvpx';
      # Pass One
      system("ffmpeg -y -i $input -codec:v $video_codec -quality $quality -cpu-used 0 -b:v 500k -qmin 10 -qmax 42 -maxrate 500k -bufsize 1000k -threads 4 -vf scale=-1:480 -an -pass 1 -f webm /dev/null");
      # Pass Two
      system("ffmpeg -y -i $input -codec:v $video_codec -quality $quality -cpu-used 0 -b:v 500k -qmin 10 -qmax 42 -maxrate 500k -bufsize 1000k -threads 4 -vf scale=-1:480 -codec:a libvorbis -b:a 128k -pass 2 -f webm $output");
  }
  1;
#+END_SRC
* Configuration
** foscam.conf
#+BEGIN_SRC fundamental :tangle foscam.conf :padline no
# General settings
STORAGE_DIRECTORY = /var/camera

# Camera 1
CAM1_NAME = cam1
CAM1_STATUS = active
CAM1_DESCRIPTION = Top of trailer, south
CAM1_IP_ADDRESS = 192.168.15.35
CAM1_USER = admin
CAM1_PASSWORD =

# Camera 2
CAM2_NAME = cam2
CAM2_STATUS = active
CAM2_DESCRIPTION = Top of trailer
CAM2_IP_ADDRESS = 192.168.15.157
CAM2_USER = admin
CAM2_PASSWORD =
CAM2_MAC_WIRED = 00:0D:C5:D7:7C:8F
CAM2_MAC_WIRELESS = 48:02:2A:46:18:47

# Camera 3
CAM3_NAME = cam3
CAM3_STATUS = active
CAM3_DESCRIPTION = Inside trailer, underneath cabinet
CAM3_IP_ADDRESS = 192.168.1.130
CAM3_USER = admin
CAM3_PASSWORD =

# Camera 4
CAM4_NAME = cam4
CAM4_STATUS = active
CAM4_DESCRIPTION = Troy's camera, on picnic table
CAM4_IP_ADDRESS = 192.168.15.2
CAM4_USER = admin
CAM4_PASSWORD =
#+END_SRC
*** temp.conf
#+BEGIN_SRC fundamental
# General settings
STORAGE_DIRECTORY = /var/camera

# Camera 1
CAM1_NAME = cam1
CAM1_STATUS = inactive
CAM1_DESCRIPTION =
CAM1_IP_ADDRESS =
CAM1_USER = admin
CAM1_PASSWORD =

# Camera 2
CAM2_NAME = cam2
CAM2_STATUS = active
CAM1_DESCRIPTION = Top of trailer
CAM2_IP_ADDRESS = 192.168.1.120
CAM2_USER = admin
CAM2_PASSWORD =

# Camera 3
CAM3_NAME = cam3
CAM3_STATUS = active
CAM3_DESCRIPTION = Inside trailer, underneath cabinet
CAM3_IP_ADDRESS = 192.168.1.130
CAM3_USER = admin
CAM3_PASSWORD =

# Camera 4 My black FOSCAM
CAM4_NAME = cam4
CAM4_STATUS = inactive
CAM4_DESCRIPTION = Troy's black FOSCAM
CAM4_IP_ADDRESS =
CAM4_USER = admin
CAM4_PASSWORD =
CAM4_WIRLELESS_MAC =
CAM4_WIRED_MAC =

#+END_SRC
* Chunks
** pragma-chunk
#+NAME: pragma-chunk
#+BEGIN_SRC perl
use warnings;
use strict;
use LWP::Simple;
use Image::Magick;
use Getopt::Long;
use FindBin qw($Bin);
use lib "$Bin/../lib";
require "foscam-perllib.pm";
require "ffmpeg-foscamlib.pm";
#+END_SRC
** read-config-chunk
#+NAME: read-config-chunk
#+BEGIN_SRC perl
### BEGIN CONFIGURATION SECTION
my $config_file = $ENV{HOME} . '/.foscam.conf';
my $BASE_DIR = "/var/camera";

my %User_Preferences;
open(CONFIG, "<", $config_file) or die "Unable to read config file $config_file: $!";
while (<CONFIG>) {
    chomp;                  # no newline
    s/#.*//;                # no comments
    s/^\s+//;               # no leading white
    s/\s+$//;               # no trailing white
    next unless length;     # anything left?
    my ($var, $value) = split(/\s*=\s*/, $_, 2);
    $User_Preferences{$var} = $value;
}
### END CONFIGURATION SECTION
#+END_SRC
** get-options-chunk
#+NAME: get-options-chunk
#+BEGIN_SRC perl
  ### BEGIN GET OPTIONS SECTION
  my $interval = 1;
  my $duration = 3600;
  my $camera_name = 'CAM2';
  my $ip_address = '192.168.1.20';
  GetOptions( "interval=i" => \$interval,
              "duration=i" => \$duration,
              "camera=s" => \$camera_name,
              "ip-address=s" => \$ip_address);
  ### END GET OPTIONS SECTION
#+END_SRC   
** Testing :noexport:
#+BEGIN_SRC sh :tangle testing/foscam.conf :padline no
# set storage directory
STORAGE_DIRECTORY = /var/camera
#+END_SRC
#+BEGIN_SRC perl :tangle testing/foo.pl :shebang #!/usr/bin/env perl :noweb yes
<<read-config-chunk>>
#+END_SRC   
* Troy Will :noexport:
  :PROPERTIES:
  :ORDERED:  t
  :END:
#+BEGIN_SRC sh :tangle ~/bin/troywill.info.sh :shebang #!/bin/bash
#!/bin/bash

export SSH_AUTH_SOCK="/tmp/ssh-ELCsfQ9RmTSO/agent.548"

RSYNC=/usr/bin/rsync 
SSH=/usr/bin/ssh 
KEY=/home/troy/.ssh/id_rsa
RUSER=troy
RHOST=shilohsystem.com
RPATH=/var/www/html/troywill.info
LPATH=/var/camera
LFILES="index.html latest-cam1.jpg latest-cam2.jpg latest-cam3.jpg latest-cam4.jpg"

cd $LPATH
$RSYNC --archive --progress --copy-links -e "$SSH -i $KEY" $LFILES $RUSER@$RHOST:$RPATH
#+END_SRC   
# SSH_AUTH_SOCK="/tmp/ssh-ELCsfQ9RmTSO/agent.548"
* * * * * $HOME/bin/troywill.info.sh >> $HOME/tmp/out 2>&1
#+BEGIN_SRC sh
#+END_SRC
* TODO Last 5 minutes upload :noexport:
#+BEGIN_SRC perl :tangle bin/foscam-last-5-minutes-upload.pl :shebang #!/usr/bin/env perl :noweb yes
<<pragma-chunk>>
<<read-config-chunk>>
<<get-options-chunk>>
#+END_SRC  
** TODO chdir current dir
* TODO MOM :noexport:
** Make links ( bin/foscam-make-links.pl )
#+BEGIN_SRC perl :tangle bin/foscam-make-links.pl :shebang #!/usr/bin/env perl :noweb yes
  <<pragma-chunk>>
  my $counter = 1;
  my $scounter = '';
      
  every_second();
  #  every_minute();
    
  make_webm('%04d.jpg', '/home/troy/webm.webm');
      
  sub make_webm {
      my ( $input, $output ) = @_;
      chdir("links") or die "Unable to chdir to links dir";
      make_two_pass_webm( $input, $output );
      chdir("..");
  }
  sub every_second {
      $counter = 1;
      my @images = <*.jpg>;
      mkdir("links");
      chdir("links") or die "Unable to chdir to links dir";
      foreach my $image  (@images) {
          $scounter = sprintf("%04d", $counter);
          symlink("../$image", "$scounter.jpg") or die "Unable to symlink";
          $counter++;
      }
      chdir("..") or die "Unable to chdir ..";
  }
  sub every_minute {
      $counter = 1;
      for my $min (0..59) {
          $min = sprintf("%02d", $min);
          my $sec = '00';
          $scounter = sprintf("%04d", $counter);
          chdir("links") or die "Unable to chdir to links dir";
          my $png = "../${min}${sec}.png";
          if ( -e $png ) {
              symlink($png, "$scounter.png");
              $counter++;
          } else {
              print "$png does not exist\n";
          }
          chdir("..") or die "Unable to chdir ..";
      }
  }
  
  sub every_ten_seconds {
      for my $min (0..59) {
          $min = sprintf("%02d", $min);
          for my $sec (0..5) {
              $sec = sprintf("%02d", $sec*10);
              $scounter = sprintf("%04d", $counter);
              chdir("links") or die "Unable to chdir to links dir";
              my $png = "../${min}${sec}.png";
              if ( -e $png ) {
                  symlink($png, "$scounter.png");
              } else {
                  print "$png does not exist\n";
              }
              chdir("..") or die "Unable to chdir ..";
              $counter++;
          }
      }
  }
  
#+END_SRC
* jpg-to-ppm-to-webm :noexport:
#+BEGIN_SRC perl :tangle bin/foscam-jpg-to-ppm-to-webm :shebang #!/usr/bin/env perl :noweb yes
    <<pragma-chunk>>
    my $time_segment = $ARGV[0];
    my $image=Image::Magick->new;
    
    my @jpegs = <*.jpg>;
    my $i = 0;
    
    mkdir("png");
    jpg_to_png();
    chdir("png") or die "Unable to chdir";
    system("ffmpeg -r 1 -i %04d.png webm.webm");
    #system("ffmpeg -r 1 -i %05d.png ogv.ogv");
    #system("ffmpeg -r 1 -i %05d.ppm avi.avi");
    #system("ffmpeg -r 1 -i %05d.ppm mkv.mkv");
    #system("ffmpeg -r 1 -i %05d.ppm mp4.mp4")
    
    sub jpg_to_png {
        foreach my $jpeg ( @jpegs ) {
            $jpeg =~ /^(\d\d)(\d\d).jpg$/;
            my ( $min, $sec ) = ( $1, $2 );
            if ( ($min >= $time_segment) && ($min < $time_segment+5) ) {
                print "[$min][$sec]\n";
                my $j = $image->Read( $jpeg );
                   my $counter = sprintf("%04d", $i);
  
                   my $text = "$min:$sec";
                   $image->Annotate(x => 50, y => 50, font=>'kai.ttf', pointsize=>10, fill=>'green', text=>$text);
  #              $j = $image->Write("png/${min}${sec}.png");
                $j = $image->Write("png/$counter.png");
                @$image = ();
                $i++;
            }
        }
    }
#+END_SRC
* foscam-daemon.pl ( foscam-daemon.pl ) :noexport:
** The main program  
#+begin_src perl :tangle bin/foscam-daemon.pl :shebang #!/usr/bin/env perl :noweb yes
  <<pragma-chunk>>
  <<get-options-chunk>>
  my $camera_name = $ARGV[0];
  my $camera_ip_address = $ARGV[1];
  my $command = "foscam-getstore-asf.pl $camera_name $camera_ip_address \&";
  print "=> $command\n" && system($command);
  sleep sleep_until_interval($interval);
  
  while (1) {
      open(my $in, "<", "log.$camera_name") or warn "Unable to open log file log.$camera_name: $!";
      while(<$in>) {
          my ($pid,$filename) = split(':',$_);
          print "PID = $pid\n";
          system("kill -15 $pid");
          print "=> $command\n" && system($command);
      }
      sleep sleep_until_interval($interval);
  }
  
  <<sleep_until_interval_subroutine>>
#+end_src
** sleep_until_interval subroutine
#+name: sleep_until_interval_subroutine
#+begin_src perl
  sub sleep_until_interval {
      my $interval_minutes = shift;
      my $sleep_until_interval = 0;
      my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
          localtime(time);
      $year -= 100;
      $mon += 1;
      
      print "DEBUG: $hour, $min, $sec\n";
      my $seconds_past_hour = $min * 60 + $sec;
      $sleep_until_interval = $seconds_past_hour%($interval_minutes*60);
      $sleep_until_interval = ($interval_minutes*60) - $sleep_until_interval;
      
      # if ( $interval_minutes == 1 ) {
      #     $sleep_until_interval = $seconds_past_hour%$interval_minutes;
      #     $sleep_until_interval = 60 - $sleep_until_interval;
      # } elsif ( $interval_minutes == 60 ) {
      #     # ONE HOUR
      #     $sleep_until_interval = 3600 - $seconds_past_hour;
      # }
      print "DEBUG: return sleep $sleep_until_interval seconds\n";
      return $sleep_until_interval;
  }
  
#+end_src
* The foscam-getstore-asf.pl program :noexport:
** Usage
#+BEGIN_EXAMPLE
foscam-getstore-asf.pl "camera_name" "ip_address"
#+END_EXAMPLE
where camera_name is an arbitrary name you give a Foscam camera and ip_addess naturally 
** What foscam-getstore-asf.pl does
** The main routine (foscam-getstore-asf.pl)
#+begin_src perl :tangle bin/foscam-getstore-asf.pl :shebang #!/usr/bin/env perl :noweb yes
my $camera_name = $ARGV[0];
my $ip_address = $ARGV[1];
use LWP::Simple;
my $url = "http://admin:\@$ip_address/videostream.asf";
$url = "http://admin:\@$ip_address/videostream.asf";
my $file = build_filename($camera_name);
my $logfile = "log.$camera_name";
print "DEBUG: opening $logfile\n";
open($log, ">", $logfile) or die "Unable to open $logfile: $!";
print $log "$$:$file\n";
close $log;
my $return = getstore($url,$file);
<<build-filename-subroutine>>
#+end_src  
** The build_filename subroutine
#+name: build-filename-subroutine
#+begin_src perl
  sub build_filename {
      my ( $camera_name, $base_dir )  = @_;
      my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
          localtime(time);
      $year -= 100;
      $mon += 1;
      my $directory = "$year/$mon/$mday/$hour/$camera_name";
      use File::Path qw(make_path);
      make_path($directory, { verbose => 1 });
      my $file = "$year/$mon/$mday/$hour/$camera_name/$year.$mon.$mday.$hour.$min.$camera_name.asf";
      return $file;
  }
#+end_src
* make mpeg video from jpegs program [ foscam-jpeg-to-mpg.pl ] 	   :noexport:
** Main
#+begin_src perl :tangle bin/foscam-jpeg-to-mpg.pl :shebang #!/usr/bin/env perl :noweb yes
my $directory = $ARGV[0] or die "Please supply a directory";
use Cwd;
my $working_dir = getcwd;
chdir $directory or die "Unable to change to $directory";
my $mpeg_video_filename = build_video_filename();
print "DEBUG: $mpeg_video_filename\n";
system("ffmpeg -f image2 -i frame_%05d.jpg $mpeg_video_filename");
chdir $working_dir or die "Unable to chdir to $working_dir";
<<build-video-filename-subroutine>>
#+end_src  
** build_video_filename subroutine
#+name: build-video-filename-subroutine
#+begin_src perl
  sub build_video_filename {
      # /home/troy/video/cam/12/11/19/9/cam1
      # /home/troy/video/cam/12/11/19/9/camtroy/JPG_
      my $asf_dir = getcwd;
      $asf_dir =~ /\/(\d+)\/(\d+)\/(\d+)\/(\d+)\/(.*?)\/(.*?)$/;
      my ( $year, $month, $day, $hour, $camera_name ) = ( $1, $2, $3, $4, $5 );
      return "/tmp/$year.$month.$day.$hour.$camera_name.mpg";
  }
#+end_src
**  http://ffmpeg.org/faq.html
#+begin_src sh
ffmpeg -f image2 -i img%d.jpg /tmp/a.mpg
#+end_src    

* Emit jpegs from the asf ( asf-to-jpeg.pl ) :noexport:
** Main program  
#+begin_src perl :tangle bin/asf-to-jpeg.pl :shebang #!/usr/bin/env perl :noweb yes
my $asf = $ARGV[0] or die;
use Cwd;
my $working_dir = getcwd;
my $jpeg_dir = make_jpeg_directory($asf);
my $time = time;
system("ffmpeg -i $asf -c:v copy -bsf:v mjpeg2jpeg $jpeg_dir/frame_%05d.jpg");
print "Made jpegs in ", time - $time, " seconds.\n";
# <<make-avi>>
# <<make-mp4>>
# <<make-mpg>>
<<make-jpeg-directory-subroutine>>
#+end_src
** Make mpg
#+name: make-mpg
#+begin_src perl
chdir($jpeg_dir) or die "Unable to chdir to $jpeg_dir: $!";
system("ffmpeg -r 5 -f image2 -i frame_%05d.jpg $jpeg_dir.mpg");
system("mv $jpeg_dir.avi ..");
chdir $working_dir or die "Unable to chdir to $working_dir: $!";
#+end_src
** Make avi
#+name: make-avi
#+begin_src perl
chdir($jpeg_dir) or die "Unable to chdir to $jpeg_dir: $!";
system("ffmpeg -r 5 -i frame_%d.jpg $jpeg_dir.avi");
system("mv $jpeg_dir.avi ..");
chdir $working_dir or die "Unable to chdir to $working_dir: $!";
#+end_src
** Make mp4
#+name: make-mp4
#+begin_src perl
chdir($jpeg_dir) or die "Unable to chdir to $jpeg_dir: $!";
system("ffmpeg -r 5 -q:v 31 -i frame_%05d.jpg $jpeg_dir.mp4");
system("mv $jpeg_dir.mp4 ..");
chdir $working_dir or die "Unable to chdir to $working_dir: $!";
#+end_src
** Make a directory in which to store the jpegs
#+name: make-jpeg-directory-subroutine
#+begin_src perl
sub make_jpeg_directory {
  my $asf = shift;
  $asf =~ /(\d+)\.asf/;
  my $dir = "JPG_$1";
  return $dir if -e $dir;
  mkdir $dir or die "Unable to make $dir dir: $!";
  return $dir;
}
#+end_src   

* Emit ppms from the asf ( asf-to-ppm.pl ) :noexport:
** Main program  
#+begin_src perl :tangle bin/asf-to-ppm.pl :shebang #!/usr/bin/env perl :noweb yes
my $asf = $ARGV[0] or die;
use Cwd;
my $working_dir = getcwd;
my $ppm_dir = make_ppm_directory($asf);
my $time = time;
system("ffmpeg -i $asf -bsf:v mjpeg2jpeg $ppm_dir/%05d.ppm");
print "Made ppms in ", time - $time, " seconds.\n";
<<make-ppm-directory-subroutine>>
#+end_src
** Make mpg
#+name: make-mpg
#+begin_src perl
chdir($jpeg_dir) or die "Unable to chdir to $jpeg_dir: $!";
system("ffmpeg -r 5 -f image2 -i frame_%05d.jpg $jpeg_dir.mpg");
system("mv $jpeg_dir.avi ..");
chdir $working_dir or die "Unable to chdir to $working_dir: $!";
#+end_src
** Make a directory in which to store the ppms
#+name: make-ppm-directory-subroutine
#+begin_src perl
sub make_ppm_directory {
  my $asf = shift;
  $asf =~ /(\d+)\.asf/;
  my $dir = "PPM_$1";
  return $dir if -e $dir;
  mkdir $dir or die "Unable to make $dir dir: $!";
  return $dir;
}
#+end_src   

* Make AVI from Jpegs  :noexport:
   
   ffmpeg -i frame_%d.jpg -c:v copy foscam.avi

* The wget program  :noexport:
#+begin_src sh
wget http://admin:@camtroy/videostream.asf
#+end_src
* Demo programs  :noexport:
** Figure out how long to sleep
#+begin_src perl :tangle sleep-until-hour.pl :shebang #!/usr/bin/env perl :noweb yes
  use warnings;
  use strict;
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
      localtime(time);
  $year -= 100;
  $mon += 1;
  print "$hour, $min, $sec\n";
  my $seconds_past_hour = $min * 60 + $sec;
  print "seconds past hour: $seconds_past_hour\n";
  my $five_minutes_sleep = $seconds_past_hour%300;
  my $one_minute_sleep = $seconds_past_hour%60;
  print "one minute modulo: $one_minute_sleep\n";
  $one_minute_sleep = 60 - $one_minute_sleep;
#  my $sleep_until = 3600 - $seconds_past_hour;
#  print "I will sleep for $sleep_until seconds\n";
  sleep $one_minute_sleep;
#+end_src
* Experiments  :noexport:
** Make pnm files
   Following doesn't work: jpeg images are created
#+begin_src sh
ffmpeg -i $asf -c:v copy -bsf:v mjpeg2jpeg $jpeg_dir/frame_%05d.pnm
#+end_src
* File naming scheme  :noexport:

#+TITLE:     foscam-perl.shilohystem.com
#+AUTHOR:    Troy Will
#+EMAIL:     troydwill@gmail.com
#+DATE:      2012-11-20 Tue
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:

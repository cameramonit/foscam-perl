* TODO foscam-convert-manager.pl
#+BEGIN_SRC perl :tangle bin/foscam-convert-manager.pl :shebang #!/usr/bin/env perl :noweb yes
  <<pragma-chunk>>
  <<read-config-chunk>>
  <<get-options-chunk>>
  use File::Basename;
  my $upload_stack_file = "/var/camera/log/$camera_name.upload";
  while ( my( $asf, $convert_status, $upload_status ) = pop_upload_stack($upload_stack_file)) {
    print "POPPED [$asf] from stack\n";
    make_and_upload_webm($asf);
  }
  
  sub make_and_upload_webm {
    my ($asf) = @_;
    my ($name,$path,$suffix) = fileparse($asf,".asf");
    print "[ name = $name ] [ path = $path ] [ suffix = $suffix ]\n";
    my $filename = get_filename_from_path($asf, $BASE_DIR);
    $filename = '/var/camera/upload/' . $filename . '.webm';
    chdir($path) or die "Unable to chdir to asf directory: $!";
    make_two_pass_webm_from_asf( "${name}${suffix}", $BASE_DIR );
    print "MOVE webm.webm $filename\n";
    rename("webm.webm",$filename);
  }
#+END_SRC
* TODO foscam-daemon.pl ( foscam-daemon.pl ) 			   :noexport:
#+BEGIN_EXAMPLE
foscam-daemon.pl --camera cam1 --ip-address cam1 --duration seconds
#+END_EXAMPLE  
** The main program  
#+begin_src perl :tangle bin/foscam-daemon.pl :shebang #!/usr/bin/env perl :noweb yes
  <<pragma-chunk>>
  <<read-config-chunk>>
  <<get-options-chunk>>
  mkdir("$BASE_DIR/run");
  mkdir("$BASE_DIR/log");
  my $command = "foscam-getstore-asf.pl --camera $camera_name --ip-address $ip_address --interval $interval\&";
  print "DAEMON => $command\n";
  system($command);
  sleep sleep_until_interval($interval);
  while (1) {
      open(my $in, "<", $PIDFILE) or die "Unable to open $PIDFILE: $!";
      while(<$in>) {
          chomp(my ($pid,$filename) = split(':',$_));
          print "[foscam-daemon.pl: stopping pid $pid\n";
          open ( my $upload_file, ">>", $UPLOADFILE ) or die "Unable to open $UPLOADFILE: $!\n";
          print $upload_file "[$filename][not converted][not uploaded]\n";
          system("kill -15 $pid");
          close $upload_file;
          print "=> DAEMON: record new video ...\n";
          system($command);
      }
      sleep sleep_until_interval($interval);
  }
#+end_src
* TODO The foscam-getstore-asf.pl program 			   :noexport:
** Usage
#+BEGIN_EXAMPLE
foscam-getstore-asf.pl "camera_name" "ip_address"
#+END_EXAMPLE
where camera_name is an arbitrary name you give a Foscam camera and ip_addess naturally 
** What foscam-getstore-asf.pl does
** The main routine (foscam-getstore-asf.pl)
#+begin_src perl :tangle bin/foscam-getstore-asf.pl :shebang #!/usr/bin/env perl :noweb yes
<<pragma-chunk>>
<<read-config-chunk>>
<<get-options-chunk>>
my $url = "http://admin:\@$ip_address/videostream.asf";
$url = "http://admin:\@$ip_address/videostream.asf";
my $file = build_video_filename($camera_name, $BASE_DIR, 'asf' );
open(my $pid, ">", $PIDFILE) or die "Unable to open $PIDFILE: $!";
print $pid "$$:$file\n";
print "[foscam-getstore-asf.pl PID $$]\n";
close $pid;
my $return = getstore($url,$file);
#+end_src  
* TODO foscam-asf-to-webm.pl
#+BEGIN_SRC perl :tangle bin/foscam-asf-to-webm.pl :shebang #!/usr/bin/env perl :noweb yes
<<pragma-chunk>>
<<read-config-chunk>>
<<get-options-chunk>>
make_two_pass_webm_from_asf($ARGV[0], $ARGV[1]);
#+END_SRC  
* Overview
The foscam-perl project is free software. This web page documents Perl programs I've written to get the video from a Foscam camera. foscam-getstore-asf.pl and foscam-daemon.pl are fully functional alpha quality programs. You can copy and paste them from this page since. You can rsync the foscam-perl project with rsync -av foscam-perl.shilohsystem.com::foscam-pel. This project
* The foscam-perl.pl program
** Usage
#+BEGIN_EXAMPLE
foscam-getstore-snapshot.pl --camera cam1 --ip-address 192.168.15.36
#+END_EXAMPLE
where camera_name is an arbitrary name you give a Foscam camera and ip_addess naturally is the ip address of the camera. 
** What foscam-perl.pl does
** The main routine (foscam-perl.pl)
#+begin_src perl :tangle bin/foscam-perl.pl :shebang #!/usr/bin/env perl :noweb yes
  <<pragma-chunk>>
  my $GET = 0;
  my $GETSTORE = 1;
  my $ANNOTATE = 0;
  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
                          clock_gettime clock_getres clock_nanosleep clock
                          stat );
  
  # get seconds and microseconds since the epoch
  my ($s0, $s1, $usec0, $usec1, $t0, $t1) = 0;
  
  my $image = Image::Magick->new;
  <<read-config-chunk>>
  <<get-options-chunk>>
  my $index = '00';
  
  $interval = 0.60;
  
  my $start_time = time;
  my $url = "http://admin:\@$ip_address/snapshot.cgi";
  $url = "http://admin:\@$ip_address/snapshot.cgi";
  my $file = build_image_filename($camera_name, $BASE_DIR, 'jpg' );
  my $logfile = "$BASE_DIR/log.$camera_name";
  open(my $log, ">", $logfile) or die "Unable to open $logfile: $!";
  while ( time < ($start_time + $duration) ) {
      ($s0, $usec0) = gettimeofday();
      print $log "--> Start at ", $s0 + $usec0/1_000_000, "\n";
      my ( $file, $text ) = build_image_filename($camera_name, $BASE_DIR, 'jpg');
      ($s0, $usec0) = gettimeofday();
      if ( $GET ) {
          my $jpeg = get($url);
          ($s0, $usec0) = log_time( $log, $s0, $usec0, "retrieved jpeg" );
          my $j = $image->BlobToImage($jpeg);
          ($s0, $usec0) = log_time( $log, $s0, $usec0, "\$image->BlobToImage" );
          if ( $ANNOTATE ) {
              print "DEBUG: \$ANNOTATE = $ANNOTATE\n";
              $image->Annotate(x => 5, y => 20, font=>'kai.ttf', pointsize=>20, fill=>'gold', text=>$text);
              ($s0, $usec0) = log_time( $log, $s0, $usec0, "\$image->Annotate" );
          }
          $j = $image->Write($file);
      } elsif ($GETSTORE) {
          my $jpeg = getstore($url,$file);
          ($s0, $usec0) = log_time( $log, $s0, $usec0, "getstore retrieved jpeg" );
      }
      my $latest_link = "$BASE_DIR/latest-${camera_name}.jpg";
      unlink($latest_link);
      symlink($file, "$latest_link") or die "Unable to symlink";
      @$image = ();
      ($s1, $usec1) = gettimeofday();
      $interval = 1 - $usec1/1_000_000;
      Time::HiRes::sleep ($interval);
  }
  sub log_time {
      my ( $filehandle, $s0, $usec0, $text ) = @_;
      my ($s1, $usec1) = gettimeofday();
  #   my $fetch_time =  ( $s1 + $usec1/1_000_000 ) - ( $s0 + $usec0/1_000_000 );
      my $elapsed_time = ($s1 + $usec1 * 1e-6) - ($s0 + $usec0 * 1e-6);
      my $milliseconds = int($elapsed_time * 1000);
      print $filehandle "$text in $milliseconds ms\n";
      return gettimeofday();
  }
  <<build-jpeg-filename-subroutine>>
  
#+end_src  
* Library
** foscam-perllib.pm
#+BEGIN_SRC perl :tangle lib/foscam-perllib.pm :padline no :noweb yes
<<get-image-dir-subroutine>>
<<make-image-dir-subroutine>>
<<build-image-filename-subroutine>>
<<build-video-filename-subroutine>>
<<get-filename-from-path>>
<<sleep-until-interval-subroutine>>
<<foscam-localtime>>
1;
#+END_SRC  
*** The get_image_directory subroutine
#+name: get-image-dir-subroutine
#+BEGIN_SRC perl
  sub get_image_dir {
      my ( $base_dir, $year, $mon, $mday, $camera_name, $hour ) = @_;
      my $directory = "$base_dir/$camera_name/$year/$mon/$mday/$hour";
      return $directory;
  }
#+END_SRC    
*** The make_image_directory subroutine
#+name: make-image-dir-subroutine
#+BEGIN_SRC perl
  sub make_image_dir {
      use File::Path qw(make_path);
      my ( $base_dir, $year, $mon, $mday, $camera_name, $hour ) = @_;
      my $directory = get_image_dir($base_dir, $year, $mon, $mday, $camera_name, $hour);
      if ( ! -e $directory ) {
          make_path($directory, { verbose => 1 }) or die "Unable to mkdir --parent $directory";
      }
      return $directory;
  }
#+END_SRC    
*** The build_image_filename subroutine
#+name: build-image-filename-subroutine
#+begin_src perl
  sub build_image_filename {
      my ( $camera_name, $base_dir, $type ) = @_;
      my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
          localtime(time);
      $year -= 100;
      $mon += 1;
      $hour = sprintf("%02d", $hour);
      $min = sprintf("%02d", $min);
      $sec = sprintf("%02d", $sec);

      my @days = qw(Sun Mon Tue Wed Thu Fri Sat);
    
      my $directory = make_image_dir( $base_dir, $year, $mon, $mday, $camera_name, $hour );
    
      my $file = "$directory/${min}${sec}.$type";
      my $text = "$days[$wday] $hour:$min:$sec";
      return ($file, $text);
  }
#+end_src

*** The build_video_filename subroutine
#+name: build-video-filename-subroutine
#+begin_src perl
  sub build_video_filename {
      print "DEBUG:   sub build_video_filename\n";
      my ( $camera_name, $base_dir, $type ) = @_;
      my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
          localtime(time);
      $year -= 100;
      $mon += 1;
      $hour = sprintf("%02d", $hour);
      $min = sprintf("%02d", $min);
      $sec = sprintf("%02d", $sec);

      my $directory = make_image_dir( $base_dir, $year, $mon, $mday, $camera_name, $hour );
    
      my $file = "$directory/${min}${sec}.$type";

      return ($file);
  }
#+end_src
*** The get_filename_from_path subroutine
#+name: build-video-filename-subroutine
#+BEGIN_SRC perl
sub get_filename_from_path {
  my ($filename, $basedir) = @_;
  $filename =~ /^$basedir(.*?)$/;
  $filename = $1;
  $filename =~ m!^/(.*?)/(\d+)/(\d+)/(\d+)/(\d+)/(\d\d)(\d\d)\.(.*?)!;  # easier to read
  my ( $camera, $year, $month, $day, $hour, $min, $sec,$extension ) = ( $1, $2, $3, $4, $5, $6, $7, $8);
  $filename = "${year}${month}${day}.${hour}${min}${sec}";
  return $filename;
}
  
#+END_SRC
*** The sleep_until_interval subroutine
#+name: sleep-until-interval-subroutine
#+begin_src perl
  sub sleep_until_interval {
      my $interval_minutes = shift;
      print "DEBUG: repeat every [$interval_minutes] minutes\n";
      my $sleep_until_interval = 0;
      my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
          localtime(time);
      $year -= 100;
      $mon += 1;
      
      my $seconds_past_hour = $min * 60 + $sec;
      $sleep_until_interval = $seconds_past_hour%($interval_minutes*60);
      
      $sleep_until_interval = ($interval_minutes*60) - $sleep_until_interval;
      
      # if ( $interval_minutes == 1 ) {
      #     $sleep_until_interval = $seconds_past_hour%$interval_minutes;
      #     $sleep_until_interval = 60 - $sleep_until_interval;
      # } elsif ( $interval_minutes == 60 ) {
      #     # ONE HOUR
      #     $sleep_until_interval = 3600 - $seconds_past_hour;
      # }
      return $sleep_until_interval;
  }
  
#+end_src
*** The foscam_localtime subroutine
#+name: foscam-localtime
#+BEGIN_SRC perl
  sub foscam_localtime {
      my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
          localtime(time);
      $year -= 100;
      $mon += 1;
      $hour = sprintf("%02d", $hour);
      $min = sprintf("%02d", $min);
      $sec = sprintf("%02d", $sec);
      
      my @days = qw(Sun Mon Tue Wed Thu Fri Sat);
      my $formated_time = "$year-$mon-$mday $hour:$min:$sec";
      return($formated_time);
  }
  
#+END_SRC    
** ffmpeg-foscamlib.pm
*** Meaning of ffmpeg options
    - -y :: Overwrite output files without asking.
*** lib/ffmpeg-foscamlib.pm
#+BEGIN_SRC perl :tangle lib/ffmpeg-foscamlib.pm :padline no :noweb yes
  use warnings;
  use strict;
  sub make_two_pass_webm {
      my ( $input, $output ) = @_;
      # my $input = shift;     # %04d.jpg
      my $quality = 'good';
      my $video_codec = 'libvpx';
      # Pass One
      system("ffmpeg -y -i $input -codec:v $video_codec -quality $quality -cpu-used 0 -b:v 500k -qmin 10 -qmax 42 -maxrate 500k -bufsize 1000k -threads 4 -vf scale=-1:480 -an -pass 1 -f webm /dev/null");
      # Pass Two
      system("ffmpeg -y -i $input -codec:v $video_codec -quality $quality -cpu-used 0 -b:v 500k -qmin 10 -qmax 42 -maxrate 500k -bufsize 1000k -threads 4 -vf scale=-1:480 -codec:a libvorbis -b:a 128k -pass 2 -f webm $output");
  }
  sub make_two_pass_webm_from_asf {
      my ( $input, $BASE_DIR ) = @_;
      print "DEBUG BASE_DIR: $BASE_DIR";
      my $logfile = "$BASE_DIR/log/webm.log";
      open(my $log, ">>", $logfile) or die "unable to open $logfile: $!";
      $input =~ /^(.*?).asf$/;
      my $basename = $1;
      # my $outputfile = "$basename.na.webm";
      my $outputfile = "webm.webm";
      my $quality = 'good';
      my $video_codec = 'libvpx';
      my $analyze_duration = '-analyzeduration 1000000000';
      my $timestamp = "";
      # system("ffmpeg -y -i $input webm/$basename.wav");
      my $one_pass_command = "ffmpeg -y $analyze_duration -i $input -c:v $video_codec -pass 1 -an -f webm $timestamp $outputfile";
      my $two_pass_command = "ffmpeg -y $analyze_duration -i $input -c:v $video_codec -pass 2 -an -f webm $timestamp $outputfile";
      print "\n", "-" x 100, "\n=> ffmpeg pass 1: $one_pass_command\n", "-" x 100, "\n";
      my $t0 = time;
      system($one_pass_command);
      print $log "[", foscam_localtime(), "] pass one in ", time - $t0, " seconds.\n";
      print "\n", "-" x 100, "\n=> ffmpeg pass 2: $two_pass_command\n", "-" x 100, "\n";
      $t0 = time;
      system($two_pass_command);
      print $log "[", foscam_localtime(), "] pass two in ", time - $t0, " seconds.\n";
      unlink("ffmpeg2pass-0.log");
      close $logfile;
  }
  1;
#+END_SRC
**** The Analyze Duration problem
#+BEGIN_EXAMPLE
[asf @ 0x947e500] max_analyze_duration 5000000 reached at 5120000
[asf @ 0x947e500] Could not find codec parameters for stream 0 (Video: mjpeg (MJPG / 0x47504A4D), 640x480): unspecified pixel format
Consider increasing the value for the 'analyzeduration' and 'probesize' options
[asf @ 0x947e500] Estimating duration from bitrate, this may be inaccurate
Guessed Channel Layout for  Input Stream #0.1 : mono
Input #0, asf, from '3000.asf':
  Duration: 06:14:04.03, start: 0.040000, bitrate: 32 kb/s
    Stream #0:0: Video: mjpeg (MJPG / 0x47504A4D), 640x480, 1k tbr, 1k tbn, 1k tbc
    Stream #0:1: Audio: adpcm_ima_wav ([17][0][0][0] / 0x0011), 8000 Hz, mono, s16, 32 kb/s
[buffer @ 0x94997a0] Unable to parse option value "-1" as pixel format
#+END_EXAMPLE      
** foscam-conversion.pm
#+BEGIN_SRC perl :tangle lib/foscam-conversion.pm :padline no :noweb yes
  use warnings;
  use strict;
  sub pop_upload_stack {
      my $upload_stack_file = shift;
      my $temp_upload_file = "tmp_upload";
      open( my $upload, "<", $upload_stack_file ) or die "Unable to open $upload_stack_file for input: $!";
      my $popline = <$upload>;
      open( my $tmp_upload, ">", $temp_upload_file ) or die "Unable to open $temp_upload_file for output: $!";
      while ( my $line = <$upload> ) {
          print $tmp_upload $line;
      }
      close $tmp_upload;
      close $upload;
      rename($temp_upload_file,$upload_stack_file) or die "Unable to rename $temp_upload_file to $upload_stack_file: $!";
      $popline =~ /\[(.*?)\]\[(.*?)\]\[(.*?)\]/;
      my ($asf, $convert_status, $upload_status ) = ($1, $2, $3);
      return ( $asf, $convert_status, $upload_status );
  }
  1;
#+END_SRC   
* Configuration
** foscam.conf
  #+BEGIN_SRC fundamental :tangle foscam.conf :padline no
  # General settings
  STORAGE_DIRECTORY = /var/camera
  
  # Camera 1
  CAM1_NAME = cam1
  CAM1_STATUS = active
  CAM1_DESCRIPTION = Top of trailer, south
  CAM1_IP_ADDRESS = 192.168.15.35
  CAM1_USER = admin
  CAM1_PASSWORD =
  
  # Camera 2
  CAM2_NAME = cam2
  CAM2_STATUS = active
  CAM2_DESCRIPTION = Top of trailer
  CAM2_IP_ADDRESS = 192.168.15.157
  CAM2_USER = admin
  CAM2_PASSWORD =
  CAM2_MAC_WIRED = 00:0D:C5:D7:7C:8F
  CAM2_MAC_WIRELESS = 48:02:2A:46:18:47
  
  # Camera 3
  CAM3_NAME = cam3
  CAM3_STATUS = active
  CAM3_DESCRIPTION = Inside trailer, underneath cabinet
  CAM3_IP_ADDRESS = 192.168.1.130
  CAM3_USER = admin
  CAM3_PASSWORD =
  
  # Camera 4
  CAM4_NAME = cam4
  CAM4_STATUS = active
  CAM4_DESCRIPTION = Troy's camera, on picnic table
  CAM4_IP_ADDRESS = 192.168.15.2
  CAM4_USER = admin
  CAM4_PASSWORD =
#+END_SRC
*** temp.conf
#+BEGIN_SRC fundamental
# General settings
STORAGE_DIRECTORY = /var/camera

# Camera 1
CAM1_NAME = cam1
CAM1_STATUS = inactive
CAM1_DESCRIPTION =
CAM1_IP_ADDRESS =
CAM1_USER = admin
CAM1_PASSWORD =

# Camera 2
CAM2_NAME = cam2
CAM2_STATUS = active
CAM1_DESCRIPTION = Top of trailer
CAM2_IP_ADDRESS = 192.168.1.120
CAM2_USER = admin
CAM2_PASSWORD =

# Camera 3
CAM3_NAME = cam3
CAM3_STATUS = active
CAM3_DESCRIPTION = Inside trailer, underneath cabinet
CAM3_IP_ADDRESS = 192.168.1.130
CAM3_USER = admin
CAM3_PASSWORD =

# Camera 4 My black FOSCAM
CAM4_NAME = cam4
CAM4_STATUS = inactive
CAM4_DESCRIPTION = Troy's black FOSCAM
CAM4_IP_ADDRESS =
CAM4_USER = admin
CAM4_PASSWORD =
CAM4_WIRLELESS_MAC =
CAM4_WIRED_MAC =

#+END_SRC
* Chunks
** pragma-chunk
#+NAME: pragma-chunk
#+BEGIN_SRC perl
use warnings;
use strict;
use LWP::Simple;
use Image::Magick;
use Getopt::Long;
use FindBin qw($Bin);
use lib "$Bin/../lib";
require "foscam-perllib.pm";
require "ffmpeg-foscamlib.pm";
require "foscam-conversion.pm";
#+END_SRC
** read-config-chunk
#+NAME: read-config-chunk
#+BEGIN_SRC perl
### BEGIN CONFIGURATION SECTION
my $config_file = $ENV{HOME} . '/.foscam.conf';
my $BASE_DIR = "/var/camera";

my %User_Preferences;
open(CONFIG, "<", $config_file) or die "Unable to read config file $config_file: $!";
while (<CONFIG>) {
    chomp;                  # no newline
    s/#.*//;                # no comments
    s/^\s+//;               # no leading white
    s/\s+$//;               # no trailing white
    next unless length;     # anything left?
    my ($var, $value) = split(/\s*=\s*/, $_, 2);
    $User_Preferences{$var} = $value;
}
### END CONFIGURATION SECTION
#+END_SRC
** get-options-chunk
#+NAME: get-options-chunk
#+BEGIN_SRC perl
  ### BEGIN GET OPTIONS SECTION
  my $interval = 1;
  my $duration = 1800;
  my $camera_name = 'CAM2';
  my $ip_address = '192.168.1.20';
  GetOptions( "interval=i" => \$interval,
              "duration=i" => \$duration,
              "camera=s" => \$camera_name,
              "ip-address=s" => \$ip_address);
  my $PIDFILE = "$BASE_DIR/run/pid.asf.$camera_name";
  my $UPLOADFILE = "$BASE_DIR/log/$camera_name.upload";
  ### END GET OPTIONS SECTION
#+END_SRC   
** Testing :noexport:
#+BEGIN_SRC sh :tangle testing/foscam.conf :padline no
# set storage directory
STORAGE_DIRECTORY = /var/camera
#+END_SRC
#+BEGIN_SRC perl :tangle testing/foo.pl :shebang #!/usr/bin/env perl :noweb yes
<<read-config-chunk>>
#+END_SRC   
* Troy Will :noexport:
  :PROPERTIES:
  :ORDERED:  t
  :END:
#+BEGIN_SRC sh :tangle ~/bin/troywill.info.sh :shebang #!/bin/bash
#!/bin/bash

export SSH_AUTH_SOCK="/tmp/ssh-ELCsfQ9RmTSO/agent.548"

RSYNC=/usr/bin/rsync 
SSH=/usr/bin/ssh 
KEY=/home/troy/.ssh/id_rsa
RUSER=troy
RHOST=shilohsystem.com
RPATH=/var/www/html/troywill.info
LPATH=/var/camera
LFILES="index.html latest-cam1.jpg latest-cam2.jpg latest-cam3.jpg latest-cam4.jpg"

cd $LPATH
$RSYNC --archive --progress --copy-links -e "$SSH -i $KEY" $LFILES $RUSER@$RHOST:$RPATH
#+END_SRC   
# SSH_AUTH_SOCK="/tmp/ssh-ELCsfQ9RmTSO/agent.548"
* * * * * $HOME/bin/troywill.info.sh >> $HOME/tmp/out 2>&1
#+BEGIN_SRC sh
#+END_SRC
* MOM :noexport:
** Make links ( bin/foscam-make-links.pl )
#+BEGIN_SRC perl :tangle bin/foscam-make-links.pl :shebang #!/usr/bin/env perl :noweb yes
  <<pragma-chunk>>
  my $counter = 1;
  my $scounter = '';
      
  every_second();
  #  every_minute();
    
  make_webm('%04d.jpg', '/home/troy/webm.webm');
      
  sub make_webm {
      my ( $input, $output ) = @_;
      chdir("links") or die "Unable to chdir to links dir";
      make_two_pass_webm( $input, $output );
      chdir("..");
  }
  sub every_second {
      $counter = 1;
      my @images = <*.jpg>;
      mkdir("links");
      chdir("links") or die "Unable to chdir to links dir";
      foreach my $image  (@images) {
          $scounter = sprintf("%04d", $counter);
          symlink("../$image", "$scounter.jpg") or die "Unable to symlink";
          $counter++;
      }
      chdir("..") or die "Unable to chdir ..";
  }
  sub every_minute {
      $counter = 1;
      for my $min (0..59) {
          $min = sprintf("%02d", $min);
          my $sec = '00';
          $scounter = sprintf("%04d", $counter);
          chdir("links") or die "Unable to chdir to links dir";
          my $png = "../${min}${sec}.png";
          if ( -e $png ) {
              symlink($png, "$scounter.png");
              $counter++;
          } else {
              print "$png does not exist\n";
          }
          chdir("..") or die "Unable to chdir ..";
      }
  }
  
  sub every_ten_seconds {
      for my $min (0..59) {
          $min = sprintf("%02d", $min);
          for my $sec (0..5) {
              $sec = sprintf("%02d", $sec*10);
              $scounter = sprintf("%04d", $counter);
              chdir("links") or die "Unable to chdir to links dir";
              my $png = "../${min}${sec}.png";
              if ( -e $png ) {
                  symlink($png, "$scounter.png");
              } else {
                  print "$png does not exist\n";
              }
              chdir("..") or die "Unable to chdir ..";
              $counter++;
          }
      }
  }
  
#+END_SRC
* jpg-to-ppm-to-webm :noexport:
#+BEGIN_SRC perl :tangle bin/foscam-jpg-to-ppm-to-webm :shebang #!/usr/bin/env perl :noweb yes
    <<pragma-chunk>>
    my $time_segment = $ARGV[0];
    my $image=Image::Magick->new;
    
    my @jpegs = <*.jpg>;
    my $i = 0;
    
    mkdir("png");
    jpg_to_png();
    chdir("png") or die "Unable to chdir";
    system("ffmpeg -r 1 -i %04d.png webm.webm");
    #system("ffmpeg -r 1 -i %05d.png ogv.ogv");
    #system("ffmpeg -r 1 -i %05d.ppm avi.avi");
    #system("ffmpeg -r 1 -i %05d.ppm mkv.mkv");
    #system("ffmpeg -r 1 -i %05d.ppm mp4.mp4")
    
    sub jpg_to_png {
        foreach my $jpeg ( @jpegs ) {
            $jpeg =~ /^(\d\d)(\d\d).jpg$/;
            my ( $min, $sec ) = ( $1, $2 );
            if ( ($min >= $time_segment) && ($min < $time_segment+5) ) {
                print "[$min][$sec]\n";
                my $j = $image->Read( $jpeg );
                   my $counter = sprintf("%04d", $i);
  
                   my $text = "$min:$sec";
                   $image->Annotate(x => 50, y => 50, font=>'kai.ttf', pointsize=>10, fill=>'green', text=>$text);
  #              $j = $image->Write("png/${min}${sec}.png");
                $j = $image->Write("png/$counter.png");
                @$image = ();
                $i++;
            }
        }
    }
#+END_SRC
* make mpeg video from jpegs program [ foscam-jpeg-to-mpg.pl ] 	   :noexport:
** Main
#+begin_src perl :tangle bin/foscam-jpeg-to-mpg.pl :shebang #!/usr/bin/env perl :noweb yes
my $directory = $ARGV[0] or die "Please supply a directory";
use Cwd;
my $working_dir = getcwd;
chdir $directory or die "Unable to change to $directory";
my $mpeg_video_filename = build_video_filename();
print "DEBUG: $mpeg_video_filename\n";
system("ffmpeg -f image2 -i frame_%05d.jpg $mpeg_video_filename");
chdir $working_dir or die "Unable to chdir to $working_dir";
<<build-video-filename-subroutine>>
#+end_src  
**  http://ffmpeg.org/faq.html
#+begin_src sh
ffmpeg -f image2 -i img%d.jpg /tmp/a.mpg
#+end_src    

* Emit jpegs from the asf ( asf-to-jpeg.pl ) :noexport:
** Main program  
#+begin_src perl :tangle bin/asf-to-jpeg.pl :shebang #!/usr/bin/env perl :noweb yes
my $asf = $ARGV[0] or die;
use Cwd;
my $working_dir = getcwd;
my $jpeg_dir = make_jpeg_directory($asf);
my $time = time;
system("ffmpeg -i $asf -c:v copy -bsf:v mjpeg2jpeg $jpeg_dir/frame_%05d.jpg");
print "Made jpegs in ", time - $time, " seconds.\n";
# <<make-avi>>
# <<make-mp4>>
# <<make-mpg>>
<<make-jpeg-directory-subroutine>>
#+end_src
** Make mpg
#+name: make-mpg
#+begin_src perl
chdir($jpeg_dir) or die "Unable to chdir to $jpeg_dir: $!";
system("ffmpeg -r 5 -f image2 -i frame_%05d.jpg $jpeg_dir.mpg");
system("mv $jpeg_dir.avi ..");
chdir $working_dir or die "Unable to chdir to $working_dir: $!";
#+end_src
** Make avi
#+name: make-avi
#+begin_src perl
chdir($jpeg_dir) or die "Unable to chdir to $jpeg_dir: $!";
system("ffmpeg -r 5 -i frame_%d.jpg $jpeg_dir.avi");
system("mv $jpeg_dir.avi ..");
chdir $working_dir or die "Unable to chdir to $working_dir: $!";
#+end_src
** Make mp4
#+name: make-mp4
#+begin_src perl
chdir($jpeg_dir) or die "Unable to chdir to $jpeg_dir: $!";
system("ffmpeg -r 5 -q:v 31 -i frame_%05d.jpg $jpeg_dir.mp4");
system("mv $jpeg_dir.mp4 ..");
chdir $working_dir or die "Unable to chdir to $working_dir: $!";
#+end_src
** Make a directory in which to store the jpegs
#+name: make-jpeg-directory-subroutine
#+begin_src perl
sub make_jpeg_directory {
  my $asf = shift;
  $asf =~ /(\d+)\.asf/;
  my $dir = "JPG_$1";
  return $dir if -e $dir;
  mkdir $dir or die "Unable to make $dir dir: $!";
  return $dir;
}
#+end_src   

* Emit ppms from the asf ( asf-to-ppm.pl ) :noexport:
** Main program  
#+begin_src perl :tangle bin/asf-to-ppm.pl :shebang #!/usr/bin/env perl :noweb yes
my $asf = $ARGV[0] or die;
use Cwd;
my $working_dir = getcwd;
my $ppm_dir = make_ppm_directory($asf);
my $time = time;
system("ffmpeg -i $asf -bsf:v mjpeg2jpeg $ppm_dir/%05d.ppm");
print "Made ppms in ", time - $time, " seconds.\n";
<<make-ppm-directory-subroutine>>
#+end_src
** Make mpg
#+name: make-mpg
#+begin_src perl
chdir($jpeg_dir) or die "Unable to chdir to $jpeg_dir: $!";
system("ffmpeg -r 5 -f image2 -i frame_%05d.jpg $jpeg_dir.mpg");
system("mv $jpeg_dir.avi ..");
chdir $working_dir or die "Unable to chdir to $working_dir: $!";
#+end_src
** Make a directory in which to store the ppms
#+name: make-ppm-directory-subroutine
#+begin_src perl
sub make_ppm_directory {
  my $asf = shift;
  $asf =~ /(\d+)\.asf/;
  my $dir = "PPM_$1";
  return $dir if -e $dir;
  mkdir $dir or die "Unable to make $dir dir: $!";
  return $dir;
}
#+end_src   

* Make AVI from Jpegs  :noexport:
   
   ffmpeg -i frame_%d.jpg -c:v copy foscam.avi

* The wget program  :noexport:
#+begin_src sh
wget http://admin:@camtroy/videostream.asf
#+end_src
* Demo programs  :noexport:
** Figure out how long to sleep
#+begin_src perl :tangle sleep-until-hour.pl :shebang #!/usr/bin/env perl :noweb yes
  use warnings;
  use strict;
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
      localtime(time);
  $year -= 100;
  $mon += 1;
  print "$hour, $min, $sec\n";
  my $seconds_past_hour = $min * 60 + $sec;
  print "seconds past hour: $seconds_past_hour\n";
  my $five_minutes_sleep = $seconds_past_hour%300;
  my $one_minute_sleep = $seconds_past_hour%60;
  print "one minute modulo: $one_minute_sleep\n";
  $one_minute_sleep = 60 - $one_minute_sleep;
#  my $sleep_until = 3600 - $seconds_past_hour;
#  print "I will sleep for $sleep_until seconds\n";
  sleep $one_minute_sleep;
#+end_src
* Experiments  :noexport:
** Make pnm files
   Following doesn't work: jpeg images are created
#+begin_src sh
ffmpeg -i $asf -c:v copy -bsf:v mjpeg2jpeg $jpeg_dir/frame_%05d.pnm
#+end_src
* File naming scheme  :noexport:

#+TITLE:     foscam-perl.shilohystem.com
#+AUTHOR:    Troy Will
#+EMAIL:     troydwill@gmail.com
#+DATE:      2012-11-20 Tue
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:
